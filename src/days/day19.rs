use regex::Regex;
use std::fs::read_to_string;
use std::ops::{Add, Sub};

#[derive(Copy, Clone)]
struct Value {
    values: [usize; 4],
}

impl Add for Value {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        let mut values = [0; 4];
        for n in 0..values.len() {
            values[n] = self.values[n] + other.values[n];
        }
        Self { values }
    }
}

impl Sub for Value {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        let mut values = [0; 4];
        for n in 0..values.len() {
            values[n] = self.values[n] - other.values[n];
        }
        Self { values }
    }
}

impl Value {
    fn new(values: [usize; 4]) -> Value {
        Value { values }
    }

    fn each_greater_equal(&self, other: &Value) -> bool {
        for n in 0..other.values.len() {
            if other.values[n] > self.values[n] {
                return false;
            }
        }
        true
    }
}

#[derive(Clone)]
struct Blueprint {
    id: usize,
    prices: [Value; 4],
}

#[derive(Copy, Clone)]
struct State {
    step: usize,
    // This is a bit of a type error...
    robots: Value,
    inventory: Value,
}

impl State {
    fn value(&self) -> usize {
        self.inventory.values[3]
    }

    // This should be as conservative as possible, while still maintaining the invariant that
    // it never underestimates the possible score of a state. It accomplishes this by giving each
    // build option a separate inventory, so the choice to build A never interferes with B,
    // but both are constrained individually by starting resources.
    fn best_outcome(&self, search: &Search) -> usize {
        let mut clone = self.clone();

        let mut split_inv = [clone.inventory; 4];

        for _ in self.step..search.depth {
            let mut new_robots = clone.robots;
            for c in 0..4 {
                if split_inv[c].each_greater_equal(&search.blueprint.prices[c]) {
                    split_inv[c] = split_inv[c] - search.blueprint.prices[c];
                    new_robots.values[c] += 1;
                }
                split_inv[c] = split_inv[c] + clone.robots;
            }

            clone.inventory = clone.inventory + clone.robots;

            // Robots built this turn shouldn't produce goods
            clone.robots = new_robots;
        }

        clone.value()
    }

    fn successors(&self, search: &Search) -> Vec<State> {
        let mut out = vec![];

        if self.step == search.depth {
            return vec![];
        }

        // This picks a build option, and waits for enough resources to be generated
        for n in 0..4 {
            // Don't try to build something in input materials aren't being produced
            if n == 2 || n == 3 {
                if self.robots.values[n - 1] == 0 {
                    continue;
                }
            }

            let mut clone = self.clone();

            // Wait until sufficient resources exist
            loop {
                clone.step += 1;
                let old_inventory = clone.inventory;
                clone.inventory = clone.inventory + clone.robots;

                if old_inventory.each_greater_equal(&search.blueprint.prices[n]) {
                    clone.inventory = clone.inventory - search.blueprint.prices[n];
                    clone.robots.values[n] += 1;
                    if clone.step <= search.depth {
                        out.push(clone);
                    }

                    break;
                }
            }
        }

        // If no build options are available (sufficient resources won't be generated by the end
        // of the search period), generate a single choice that waits until the end.
        if out.len() == 0 {
            let mut clone = self.clone();
            while clone.step < search.depth {
                clone.step += 1;
                clone.inventory = clone.inventory + clone.robots;
            }

            out.push(clone);
        }

        out
    }
}

struct Search {
    depth: usize,
    blueprint: Blueprint,
    initial_state: State,
}

struct SearchScratch {
    best: Option<State>,
    iters: usize,
}

impl Search {
    // Performs a depth first search, using best possible outcome above both to prune paths and
    // prioritize search order.
    fn search_inner(&self, scratch: &mut SearchScratch, state: State) {
        let mut succ = state.successors(&self);

        scratch.iters += 1;
        succ.sort_by(|a, b| b.best_outcome(&self).cmp(&a.best_outcome(&self)));

        for v in succ {
            if let Some(b) = scratch.best {
                if b.value() >= v.best_outcome(&self) {
                    continue;
                }
            }

            if let Some(b) = scratch.best {
                if b.value() < v.value() {
                    scratch.best = None;
                }
            };

            if scratch.best.is_none() {
                scratch.best = Some(v);
            }

            if v.step < self.depth {
                self.search_inner(scratch, v);
            }
        }
    }

    fn search(&self) -> usize {
        let mut scratch = SearchScratch {
            best: None,
            iters: 0,
        };

        self.search_inner(&mut scratch, self.initial_state);

        scratch.best.unwrap().value()
    }
}

pub fn day_19() -> (String, String) {
    let f = read_to_string("input/day19.txt").unwrap();
    let re = Regex::new(
        r"^Blueprint (\d+): Each ore robot costs (\d+) ore\. Each clay robot costs (\d+) ore\. Each obsidian robot costs (\d+) ore and (\d+) clay\. Each geode robot costs (\d+) ore and (\d+) obsidian\.$",
    ).unwrap();

    let mut blueprints = vec![];

    for l in f.lines() {
        let c = re.captures(l).unwrap();
        let v = |i: usize| str::parse::<usize>(&c[i + 1]).unwrap();

        blueprints.push(Blueprint {
            id: v(0),
            prices: [
                Value::new([v(1), 0, 0, 0]),
                Value::new([v(2), 0, 0, 0]),
                Value::new([v(3), v(4), 0, 0]),
                Value::new([v(5), 0, v(6), 0]),
            ],
        });
    }

    // Part A: All blueprints searched, generate a quality score, sum into accumulator
    let mut part_a = 0;

    for b in &blueprints {
        let search = Search {
            depth: 24,
            blueprint: b.clone(),
            initial_state: State {
                step: 0,
                inventory: Value::new([0, 0, 0, 0]),
                robots: Value::new([1, 0, 0, 0]),
            },
        };

        let res = search.search();

        part_a += b.id * res;
    }

    // Part B: First three blueprints searched, multiply result into accumulator
    let mut part_b = 1;
    for n in 0..3 {
        let search = Search {
            depth: 32,
            blueprint: blueprints[n].clone(),
            initial_state: State {
                step: 0,
                inventory: Value::new([0, 0, 0, 0]),
                robots: Value::new([1, 0, 0, 0]),
            },
        };

        let res = search.search();
        part_b *= res;
    }

    (format!("{part_a}"), format!("{part_b}"))
}
